# -*- coding: utf-8 -*-
# GNU General Public License v3.0+ (see COPYING or https://www.gnu.org/licenses/gpl-3.0.txt)

# This code is part of Ansible, but is an independent component.
# This particular file snippet, and this file snippet only, is Apache2.0 licensed.
# Modules you write using this snippet, which is embedded dynamically by Ansible
# still belong to the author of the module, and may assign their own license
# to the complete work.
#
# Copyright (c) 2024 Calvin Remsburg (@cdot65)
# All rights reserved.

"""
Ansible module for managing vulnerability protection profile objects in SCM.

This module provides functionality to create, update, and delete vulnerability protection profile objects
in the SCM (Strata Cloud Manager) system. It handles various profile attributes
and supports check mode operations.
"""

from __future__ import absolute_import, division, print_function

__metaclass__ = type

from ansible.module_utils._text import to_text
from ansible.module_utils.basic import AnsibleModule
from pydantic import ValidationError

from ansible_collections.cdot65.scm.plugins.module_utils.api_spec.vulnerability_protection_profile import (  # noqa: F401
    VulnerabilityProtectionProfileSpec,
)
from ansible_collections.cdot65.scm.plugins.module_utils.authenticate import (  # noqa: F401
    get_scm_client,
)
from ansible_collections.cdot65.scm.plugins.module_utils.serialize_response import (  # noqa: F401
    serialize_response,
)
from scm.config.security.vulnerability_protection_profile import VulnerabilityProtectionProfile
from scm.exceptions import InvalidObjectError, NameNotUniqueError, ObjectNotPresentError
from scm.models.security.vulnerability_protection_profiles import (
    VulnerabilityProfileUpdateModel,
)

DOCUMENTATION = r"""
---
module: vulnerability_protection_profile

short_description: Manage vulnerability protection profile objects in SCM.

version_added: "0.1.0"

description:
    - Manage vulnerability protection profile objects within Strata Cloud Manager (SCM).
    - Create, update, and delete vulnerability protection profile objects to protect against known vulnerabilities.
    - Configure rules based on severity levels, categories, and CVEs.
    - Define actions to take when vulnerabilities are detected.
    - Set up threat exceptions for specific scenarios.
    - Ensures that at least one rule is provided for create/update operations.
    - Ensures that exactly one container type (folder, snippet, device) is provided.

options:
    name:
        description: The name of the vulnerability protection profile (max 63 chars).
        required: true
        type: str
    description:
        description: Description of the vulnerability protection profile (max 1023 chars).
        required: false
        type: str
    rules:
        description: List of vulnerability protection rules to apply. At least one rule is required.
        required: true
        type: list
        elements: dict
        suboptions:
            name:
                description: Name of the rule.
                required: true
                type: str
            severity:
                description: List of severity levels this rule applies to.
                required: true
                type: list
                elements: str
                choices: ['critical', 'high', 'medium', 'low', 'informational', 'any']
            cve:
                description: List of CVE IDs that this rule applies to.
                required: false
                type: list
                elements: str
            category:
                description: Category of vulnerability that this rule applies to.
                required: true
                type: str
                choices: ['any', 'buffer-overflow', 'code-execution', 'format-string', 'remote-code-execution', 
                          'authentication-bypass', 'command-injection', 'data-flow', 'privilege-escalation', 
                          'sql-injection', 'vulnerabilities', 'memory-corruption', 'integer-overflow', 
                          'directory-traversal', 'memory-overflow', 'information-disclosure', 'server-applications',
                          'xml-external-entity', 'browser-application', 'local-guest-virtual-machine-escape',
                          'xml-document-type-definition', 'cross-site-scripting', 'use-after-free', 'heap-overflow',
                          'cross-site-request-forgery', 'resource-exhaustion', 'integer-underflow', 'race-condition',
                          'stack-overflow', 'information-theft', 'command-shell', 'buffer-underflow', 'shellshock',
                          'content-spoofing', 'client-applications', 'denial-of-service', 'log-injection',
                          'clickjacking', 'path-traversal', 'request-smuggling', 'reply-injection', 'fuzzing',
                          'web-applications', 'unauthorized-access', 'other']
            host:
                description: Type of host (client or server) that this rule applies to.
                required: true
                type: str
                choices: ['any', 'client', 'server']
            vendor:
                description: List of vendor names to match in this rule.
                required: false
                type: list
                elements: str
            packet_capture:
                description: Type of packet capture to perform when rule matches.
                required: false
                type: str
                choices: ['disable', 'single-packet', 'extended-capture']
            action:
                description: Action to take when the rule matches.
                required: true
                type: str
                choices: ['default', 'allow', 'alert', 'drop', 'reset-client', 'reset-server', 'reset-both', 'block-ip']
            block_ip_track_by:
                description: Tracking method for block-ip action.
                required: false
                type: str
                choices: ['source', 'destination', 'source-and-destination']
            block_ip_duration:
                description: Duration in seconds for block-ip action.
                required: false
                type: int
    threat_exception:
        description: List of exceptions to the vulnerability rules.
        required: false
        type: list
        elements: dict
        suboptions:
            name:
                description: Name of the threat exception.
                required: true
                type: str
            packet_capture:
                description: Type of packet capture to perform for this exception.
                required: true
                type: str
                choices: ['disable', 'single-packet', 'extended-capture']
            exempt_ip:
                description: List of IP addresses to exempt from this rule.
                required: false
                type: list
                elements: dict
                suboptions:
                    name:
                        description: Exempt IP address or range.
                        required: true
                        type: str
            notes:
                description: Additional notes for the threat exception.
                required: false
                type: str
            action:
                description: Action to take for excepted traffic.
                required: true
                type: str
                choices: ['default', 'allow', 'alert', 'drop', 'reset-client', 'reset-server', 'reset-both', 'block-ip']
            block_ip_track_by:
                description: Tracking method for block-ip action in exception.
                required: false
                type: str
                choices: ['source', 'destination', 'source-and-destination']
            block_ip_duration:
                description: Duration in seconds for block-ip action in exception.
                required: false
                type: int
    folder:
        description: The folder in which the profile is defined (max 64 chars).
        required: false
        type: str
    snippet:
        description: The snippet in which the profile is defined (max 64 chars).
        required: false
        type: str
    device:
        description: The device in which the profile is defined (max 64 chars).
        required: false
        type: str
    provider:
        description: Authentication credentials.
        required: true
        type: dict
        suboptions:
            client_id:
                description: Client ID for authentication.
                required: true
                type: str
            client_secret:
                description: Client secret for authentication.
                required: true
                type: str
            tsg_id:
                description: Tenant Service Group ID.
                required: true
                type: str
            log_level:
                description: Log level for the SDK.
                required: false
                type: str
                default: "INFO"
    state:
        description: Desired state of the vulnerability protection profile.
        required: true
        type: str
        choices:
          - present
          - absent

author:
    - Calvin Remsburg (@cdot65)
"""

EXAMPLES = r"""
---
- name: Manage Vulnerability Protection Profiles in Strata Cloud Manager
  hosts: localhost
  gather_facts: false
  vars_files:
    - vault.yaml
  vars:
    provider:
      client_id: "{{ client_id }}"
      client_secret: "{{ client_secret }}"
      tsg_id: "{{ tsg_id }}"
      log_level: "INFO"
  tasks:

    - name: Create a vulnerability protection profile with basic rules
      cdot65.scm.vulnerability_protection_profile:
        provider: "{{ provider }}"
        name: "Basic-Vuln-Protection"
        description: "Basic vulnerability protection profile"
        folder: "Texas"
        rules:
          - name: "Block-Critical-Vulnerabilities"
            severity: ["critical"]
            category: "any"
            host: "any"
            action: "reset-both"
            packet_capture: "single-packet"
          - name: "Alert-High-Vulnerabilities"
            severity: ["high"]
            category: "any"
            host: "any"
            action: "alert"
        state: "present"

    - name: Create a comprehensive vulnerability protection profile
      cdot65.scm.vulnerability_protection_profile:
        provider: "{{ provider }}"
        name: "Advanced-Vuln-Protection"
        description: "Advanced vulnerability protection with specific CVEs and exceptions"
        folder: "Texas"
        rules:
          - name: "Block-Critical-RCE"
            severity: ["critical"]
            category: "remote-code-execution"
            host: "server"
            action: "reset-both"
            packet_capture: "extended-capture"
            cve: ["CVE-2021-44228", "CVE-2022-22965"]
          - name: "Block-SQL-Injection"
            severity: ["critical", "high"]
            category: "sql-injection"
            host: "server"
            action: "reset-client"
          - name: "Alert-XSS"
            severity: ["high", "medium"]
            category: "cross-site-scripting"
            host: "client"
            action: "alert"
        threat_exception:
          - name: "Dev-Environment-Exception"
            packet_capture: "single-packet"
            action: "alert"
            exempt_ip:
              - name: "10.0.2.0/24"
            notes: "Exception for dev environment testing"
        state: "present"

    - name: Update a vulnerability protection profile with new rules
      cdot65.scm.vulnerability_protection_profile:
        provider: "{{ provider }}"
        name: "Basic-Vuln-Protection"
        description: "Updated vulnerability protection profile"
        folder: "Texas"
        rules:
          - name: "Block-Critical-Vulnerabilities"
            severity: ["critical"]
            category: "any"
            host: "any"
            action: "reset-both"
            packet_capture: "single-packet"
          - name: "Alert-High-Vulnerabilities"
            severity: ["high"]
            category: "any"
            host: "any"
            action: "alert"
          - name: "New-Medium-Rule"
            severity: ["medium"]
            category: "any"
            host: "any"
            action: "alert"
        state: "present"

    - name: Delete a vulnerability protection profile
      cdot65.scm.vulnerability_protection_profile:
        provider: "{{ provider }}"
        name: "Basic-Vuln-Protection"
        folder: "Texas"
        state: "absent"
"""

RETURN = r"""
changed:
    description: Whether any changes were made.
    returned: always
    type: bool
    sample: true
vulnerability_protection_profile:
    description: Details about the vulnerability protection profile.
    returned: when state is present
    type: dict
    sample:
        id: "123e4567-e89b-12d3-a456-426655440000"
        name: "Basic-Vuln-Protection"
        description: "Basic vulnerability protection profile"
        folder: "Texas"
        rules:
          - name: "Block-Critical-Vulnerabilities"
            severity: ["critical"]
            category: "any"
            host: "any"
            action: "reset-both"
            packet_capture: "single-packet"
          - name: "Alert-High-Vulnerabilities"
            severity: ["high"]
            category: "any"
            host: "any"
            action: "alert"
"""


def convert_action(action_value):
    """
    Convert action value to the format expected by the SDK.

    If action is a string, convert it to a dictionary format:
    'reset-both' -> {'reset_both': {}}

    Args:
        action_value: The action value (string or dict)

    Returns:
        dict: Action in dictionary format
    """
    if isinstance(action_value, dict):
        # Already in dict format, return as is
        return action_value
    elif isinstance(action_value, str):
        # Convert from string format to dict format
        # Handle special case for hyphenated values
        action_key = action_value.replace("-", "_")
        return {action_key: {}}
    else:
        # Invalid format
        return action_value


def process_rules(rules):
    """
    Process rules to ensure action is in the correct format and handle field name mappings.

    Args:
        rules (list): List of rule dictionaries

    Returns:
        list: Processed rules with actions in the correct format
    """
    if not rules:
        return rules

    processed_rules = []
    for rule in rules:
        processed_rule = rule.copy()
        # Convert action format if needed
        if "action" in processed_rule:
            processed_rule["action"] = convert_action(processed_rule["action"])

        # Handle vendor => vendor-id field mapping
        if "vendor" in processed_rule:
            processed_rule["vendor-id"] = processed_rule.pop("vendor")

        # Ensure required fields have values
        if "cve" not in processed_rule:
            processed_rule["cve"] = ["any"]

        if "packet_capture" not in processed_rule:
            processed_rule["packet_capture"] = "disable"

        processed_rules.append(processed_rule)
    return processed_rules


def process_threat_exceptions(exceptions):
    """
    Process threat exceptions to ensure action is in the correct format.

    Args:
        exceptions (list): List of exception dictionaries

    Returns:
        list: Processed exceptions with actions in the correct format
    """
    if not exceptions:
        return exceptions

    processed_exceptions = []
    for exception in exceptions:
        processed_exception = exception.copy()
        # Convert action format if needed
        if "action" in processed_exception:
            processed_exception["action"] = convert_action(processed_exception["action"])

        # Ensure name length is valid (max 10 characters)
        if "name" in processed_exception and len(processed_exception["name"]) > 10:
            processed_exception["name"] = processed_exception["name"][:10]

        # Ensure required fields have values
        if "packet_capture" not in processed_exception:
            processed_exception["packet_capture"] = "disable"

        processed_exceptions.append(processed_exception)
    return processed_exceptions


def build_profile_data(module_params):
    """
    Build vulnerability protection profile data dictionary from module parameters.

    Args:
        module_params (dict): Dictionary of module parameters

    Returns:
        dict: Filtered dictionary containing only relevant profile parameters
    """
    profile_data = {
        k: v for k, v in module_params.items() if k not in ["provider", "state"] and v is not None
    }

    # Process rules and threat exceptions to convert action formats
    if "rules" in profile_data:
        profile_data["rules"] = process_rules(profile_data["rules"])

    if "threat_exception" in profile_data:
        profile_data["threat_exception"] = process_threat_exceptions(
            profile_data["threat_exception"]
        )

    return profile_data


def is_container_specified(profile_data):
    """
    Check if exactly one container type (folder, snippet, device) is specified.

    Args:
        profile_data (dict): Profile parameters

    Returns:
        bool: True if exactly one container is specified, False otherwise
    """
    containers = [profile_data.get(container) for container in ["folder", "snippet", "device"]]
    return sum(container is not None for container in containers) == 1


def needs_update(existing, params):
    """
    Determine if the vulnerability protection profile needs to be updated.

    Args:
        existing: Existing profile object from the SCM API
        params (dict): Profile parameters with desired state from Ansible module

    Returns:
        (bool, dict): Tuple containing:
            - bool: Whether an update is needed
            - dict: Complete object data for update including all fields from the existing
                  object with any modifications from the params
    """
    changed = False

    # Start with a fresh update model using all fields from existing object
    update_data = {
        "id": str(existing.id),  # Convert UUID to string for Pydantic
        "name": existing.name,
    }

    # Add the container field (folder, snippet, or device)
    for container in ["folder", "snippet", "device"]:
        container_value = getattr(existing, container, None)
        if container_value is not None:
            update_data[container] = container_value

    # Check description parameter for changes
    current_description = getattr(existing, "description", None)
    update_data["description"] = current_description

    if "description" in params and params["description"] is not None:
        if current_description != params["description"]:
            update_data["description"] = params["description"]
            changed = True

    # Check rules for changes
    current_rules = getattr(existing, "rules", [])
    # Deep comparison would be complex, so for simplicity we'll assume rules have changed
    # if the user provides them in the parameters
    if "rules" in params and params["rules"] is not None:
        if params["rules"] != current_rules:
            update_data["rules"] = params["rules"]
            changed = True
    else:
        update_data["rules"] = current_rules

    # Check threat_exception for changes
    current_exceptions = getattr(existing, "threat_exception", [])
    if "threat_exception" in params and params["threat_exception"] is not None:
        if params["threat_exception"] != current_exceptions:
            update_data["threat_exception"] = params["threat_exception"]
            changed = True
    else:
        if current_exceptions:
            update_data["threat_exception"] = current_exceptions

    return changed, update_data


def get_existing_profile(client, profile_data):
    """
    Attempt to fetch an existing vulnerability protection profile object.

    Args:
        client: SCM client instance
        profile_data (dict): Profile parameters to search for

    Returns:
        tuple: (bool, object) indicating if profile exists and the profile object if found
    """
    try:
        # Determine which container type is specified
        container_type = None
        for container in ["folder", "snippet", "device"]:
            if container in profile_data and profile_data[container] is not None:
                container_type = container
                break

        if container_type is None or "name" not in profile_data:
            return False, None

        # Fetch the profile using the appropriate container
        existing = client.vulnerability_protection_profile.fetch(
            name=profile_data["name"], **{container_type: profile_data[container_type]}
        )
        return True, existing
    except (ObjectNotPresentError, InvalidObjectError):
        return False, None


def main():
    """
    Main execution path for the vulnerability protection profile module.

    This module provides functionality to create, update, and delete vulnerability protection profile objects
    in the SCM (Strata Cloud Manager) system. It handles various profile attributes
    and supports check mode operations.

    :return: Ansible module exit data
    :rtype: dict
    """
    argument_spec = VulnerabilityProtectionProfileSpec.spec()

    # Update the rules parameter to not be required
    argument_spec["rules"]["required"] = False

    module = AnsibleModule(
        argument_spec=argument_spec,
        supports_check_mode=True,
        mutually_exclusive=[
            ["folder", "snippet", "device"],
        ],
        required_one_of=[["folder", "snippet", "device"]],
        required_if=[
            ("state", "present", ["rules"]),
        ],
    )

    result = {"changed": False, "vulnerability_protection_profile": None}

    try:
        client = get_scm_client(module)
        profile_data = build_profile_data(module.params)

        # Validate container is specified
        if not is_container_specified(profile_data):
            module.fail_json(
                msg="Exactly one of 'folder', 'snippet', or 'device' must be provided."
            )

        # Get existing profile
        exists, existing_profile = get_existing_profile(client, profile_data)

        if module.params["state"] == "present":
            if not exists:
                # Create new profile
                if not module.check_mode:
                    try:
                        new_profile = client.vulnerability_protection_profile.create(
                            data=profile_data
                        )
                        result["vulnerability_protection_profile"] = serialize_response(new_profile)
                        result["changed"] = True
                    except NameNotUniqueError:
                        module.fail_json(
                            msg=f"A vulnerability protection profile with name '{profile_data['name']}' already exists"
                        )
                    except InvalidObjectError as e:
                        module.fail_json(
                            msg=f"Invalid vulnerability protection profile data: {str(e)}"
                        )
                else:
                    result["changed"] = True
            else:
                # Compare and update if needed
                need_update, update_data = needs_update(existing_profile, profile_data)

                if need_update:
                    if not module.check_mode:
                        # Create update model with complete object data
                        update_model = VulnerabilityProfileUpdateModel(**update_data)

                        # Perform update with complete object
                        updated_profile = client.vulnerability_protection_profile.update(
                            update_model
                        )
                        result["vulnerability_protection_profile"] = serialize_response(
                            updated_profile
                        )
                        result["changed"] = True
                    else:
                        result["changed"] = True
                else:
                    # No changes needed
                    result["vulnerability_protection_profile"] = serialize_response(
                        existing_profile
                    )

        elif module.params["state"] == "absent":
            if exists:
                if not module.check_mode:
                    client.vulnerability_protection_profile.delete(str(existing_profile.id))
                result["changed"] = True

        module.exit_json(**result)

    except Exception as e:
        module.fail_json(msg=to_text(e))


if __name__ == "__main__":
    main()
